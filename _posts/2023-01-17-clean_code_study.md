---
title:  "Clean Code 책 정리"
excerpt: "Clean Code 책을 읽고 내용을 정리해보았다"

categories:
  - Book
tags:
  - Clean Code
  - Java
last_modified_at: 2023-01-17 
toc: true
toc_label: "Contents"
toc_icon: "cog"
toc_sticky: true
---

---

### Clean Code 책을 선택한 이유

![클린코드](https://user-images.githubusercontent.com/54565079/213316914-f73f3177-389c-4b32-9df1-461f1914e752.jpg)

제목을 보고 본능적으로 끌렸던 것 같다. 어느 언어, 기술, 프레임워크를 접하든 개발을 하는 사람이라면 코드는 계속 보고 작성할 수 밖에 없다. 내 경험상 개인프로젝트를 할 때는 정해진 기한이 없는 경우가 많아서 마음의 여유가 있고 그래서 중간에 코드를 리팩토링 하거나 원하는 방식으로 주석을 다는 방식으로 코드의 방식에 대한 고민이 별로 없었다. 하지만 협업을 하다보면 제한된 프로젝트 기한이 주는 촉박함도 있고 같이 협업하는 사람과의 코드 작성 방식의 차이도 존재하다보니 개발을 하면 할수록 소위 말해 '개판'이 되기가 쉬운 것 같다. 프로젝트 내에 코드의 일관성도 줄어들고 프로젝트가 고도화될 수록 다른 사람의 코드는 물론이고 내 코드를 해석하는 것도 점점 시간이 오래걸리면서 생산성이 갈수록 떨어지는 것 같다. 이런 경험을 하고 나니 이 책의 제목을 보고 목차를 본 순간 무조건 읽어야 한다는 생각이 들었다. 이 글에는 책의 수백페이지를 다 읽지 않아도 책에서 말하고자 하는 바를 몇분 이내로 다 알 수 있도록, 그래서 다른 사람에게도 도움이 되지만 내가 다시 봐도 2독, 3독한 효과를 받을 수 있도록 각 챕터별로 요약한 내용을 정리해 보았다.



#### 목차

1. [깨끗한 코드](#1-깨끗한-코드)
2. [의미 있는 이름](#2-의미-있는-이름)
3. [함수](#3-함수)
4. [주석](#4-주석)
5. [형식 맞추기](#5-형식-맞추기)
6. [객체와 자료구조](#6-객체와-자료구조)
7. [오류 처리](#7-오류-처리)
8. 경계
9. 단위 테스트
10. 클래스
11. 시스템
12. 창발성
13. 동시성
14. 점진적인 개선
15. JUnit
16. SerialDate 리팩터링
17. 냄새와 휴리스틱



### 1. 깨끗한 코드

#### Clean Code란

클린 코드의 정의는 아마 개발자의 수만큼이나 정의도 다양할거라고 생각한다. 아래는 세계적인 개발자들이 정의한 '클린 코드'이다. 

- Bjarne Stroustrup(C++ 창시자) : 우아하고 효율적인 코드이다. 논리가 간단해야 버그가 숨어들지 못한다. 의존성을 최대한 줄여야 유지보수가 쉬워진다. 깨끗한 코드는 한가지를 제대로 한다. 
  - 효율 강조
- Grady Booch(UML 개발자) : 깨끗한 코드는 단순하고 직접적이다. 깨끗한 코드는 잘 쓴 문장처럼 읽힌다. 깨끗한 코드는 설계자의 의도를 숨기지 않는다. 오히려 명쾌한 추상화와 단순한 제어문으로 가득하다. 
  - 가독성 강조
- Dave Thomas(OTI 창립자) : 깨끗한 코드는 작성자가 아닌 사람도 읽기 쉽고 고치기 쉽다. 단위 테스트 케이스와 인수 테스트 케이스가 존재한다. 깨끗한 코드에는 의미있는 이름이 붙는다. 특정 목적을 달성하는 방법은 하나만 제공한다. 의존성은 최소이며 각 의존성을 명확히 정의한다. 
  - 가독성 강조, TDD(Test Driven Development) 강조
- Michael Feathers(레거시 코드 활용 전략 저자) : 깨끗한 코드는 언제나 주의 깊게 짰다는 느낌을 준다. 고치려고 살펴봐도 딱히 손 댈 곳이 없다. 작성자가 이미 모든 사항을 고려했기 때문에 고칠 궁리를 하다 보면 언제나 제자리로 돌아온다. 
  - 주의를 기울인 코드 강조 
- Ron Jeffries(Extreme Programming 개발 방법론 창시자) : 나는 주로 중복에 집중한다. 같은 작업을 여러 차례 반복한다면 코드가 아이디어를 제대로 표현하지 못한다는 증거다. 나는 문제의 아이디어를 찾아내 좀 더 명확하게 표현하려 애쓴다. 집합을 추상화 하면 '진짜' 문제에 신경 쓸 여유가 생긴다. 
  - 중복을 피하고 추상화된 코드 강조

- Ward Cunningham(Wiki 창시자) : 코드를 읽으면서 짐작했던 기능을 그대로 수행한다면 깨끗한 코드이다. 
  - 명백하고 단순한 코드 강조




#### 보이스카우트 규칙

- '캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라'
  - 코드는 시간이 지나도 언제나 깨끗하게 유지해야 한다
  - 체크아웃 할 때 보다 깨끗한 코드를 확인한다면 코드는 절대 나빠지지 않는다
  - 한꺼번에 많은 시간과 노력을 투자해 코드를 정리할 필요가 없다 (변수 이름 하나 개선, 긴 함수 하나 분할, 복잡한 if문 하나 제거 등)



### 2. 의미 있는 이름

프로그래머는 코드를 최대한 이해하기 쉽게 짜야 한다. 집중적인 탐구가 필요한 코드가 아닌 대충 훑어봐도 이해할 코드 작성을 목표로 해야 한다. 그러기 위해서는 변수의 이름을 신중하게 결정할 필요가 있다. 소프트웨어에서 이름은 어디에나 쓰인다. 변수, 함수, 인수와 클래스, 패키지, 소스파일, jar/war 파일 등에도 이름을 붙인다. 그렇기 때문에 이름을 잘 지으면 여러모로 편하다. 



#### 의도 명확하게 하기

좋은 이름을 지으려면 시간이 걸리지만 좋은 이름으로 절약하는 시간이 훨씬 더 많다. 변수, 함수, 클래스 이름은 다음의 질문에 모두 답해야 한다. 

- 존재 이유
- 수행 기능
- 사용 방법

따로 주석이 필요하다면 의도를 분명히 드러내지 못했다는 말이다. 

~~~java
// 나쁜 예시
int d; 

// 좋은 예시
int elapsedTimeInDays;
int daysSinceCreation;
int daysSinceModification;
int fileAgeInDays;
~~~



#### 클래스 이름

클래스 이름과 객체 이름은 명사가 적합하다.



#### 메서드 이름

메서드 이름은 동사가 적합하다. 



#### 한 개념에 한 단어만 사용하기

추상적인 개념 하나에 단어 하나를 선택해 이를 고수해야 한다. 

> 똑같은 메서드를 클래스마다 fetch, retrieve, get으로 제각각 부르면 혼란스럽다. 요즘 에디터들은 좋은 메서드 이름을 자동으로 추천해주는 기능이 있다. 



#### 한 단어를 두가지 목적으로 사용하지 않기

같은 개념처럼 보여도 맥락이 다르다면 다른 단어를 사용해야 한다. 

> add가 들어간 메서드들이 있다고 가정했을 때 어떤 add 메서드는 기존 값 두개를 더해서 새로운 값을 만들고 어떤 add는 집합에 값 하나를 추가하는 경우가 있다고 하자. 이 경우에는 add라는 단어의 맥락이 다르기 때문에 add 라는 단어가 아닌 insert나 append라는 단어로 구분할 필요가 있다. 



#### 의미있는 맥락 추가하기

클래스, 함수, 혹은 접두어 등에 맥락을 부여하는게 좋다.

> firstName, lastName, street, houseNumber, city, state 라는 변수들을 훑어보면 주소라는 사실을 금방 알 수 있다. 하지만 어느 메서드가 state 변수 하나만 사용한다면 state가 주소를 의미하는지 알기 어렵다. addr라는 접두어를 추가해 addrFirstName, addrLastName, addrState라고 쓰면 맥락이 분명해진다. 다른 방법으로는 Address라는 클래스를 생성하는 방법도 좋다. 



### 3. 함수

어떤 프로그램이든 가장 기본적인 단위는 함수다. 함수를 잘 활용하면 가독성 있는 코드를 작성할 수 있다. 



#### 작게 만들기

함수는 길면 안된다. 최대 100줄을 넘겨서도 안된다. 중첩 구조가 생길만큼 함수가 커져서도 안된다. 그래야 함수는 읽고 이해하기 쉬워진다. 



#### 한가지만 하기

함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다. 함수가 한 가지만 하느지의 여부를 알 수 있는 방법은 함수의 이름을 지을 때 의미 있는 이름으로 다른 함수를 추출할 수 있다면 함수는 한 가지의 일을 하는게 아닌 것이다. 



#### 함수 인수

- 함수 인수의 가장 이상적인 개수는 0개(무항)이다. 그 다음은 1개이고 그 다음은 2개이다. 3개 이상은 가능한 피하는 편이 좋다. 인수가 많을 수록 이해하기 어려운 코드가 된다. 

- 함수 인수에 bool 값을 넘기는 것도 좋지 않다. 함수가 한꺼번에 여러가지 일을 한다고 말하는 것과 같다. 

- 인수가 2~3개 필요하다면 일부를 독자적인 클래스 변수로 선언할 수 있는지 확인하는게 좋다. 

- ```java
  Circle makeCircle(double x, double y, double radius);
  Circle makeCircle(Point center, double radius); // 가독성 향상
  ```



#### 부수효과를 일으키지 않기

함수에서 한가지를 하지 않고 몰래 다른 일을 하게 된다면 심각한 부작용을 가져올 수 있다. 함수로 넘어온 인수나 전역변수를 수정할 수도 있다. 많은 경우 시간적인 결합(temporal coupling)이나 순서 종속성(order dependency)를 초래한다. 



#### 명령과 조회를 분리하기

함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다. 객체 상태를 변경하거나 객체 정보를 반환하거나 둘 중 하나만 해야 한다. 두가지를 같이 하면 혼란을 초래하게 된다. 



#### Try/catch 사용하기

Try/catch를 사용하면 오류 처리 코드가 원래 코드에서 분리되어서 코드가 깔끔해진다. 적용한 try/catch 블록을 별도의 함수로 뽑아내면 더 좋다. 



#### 반복하지 않기

중복은 코드 길이가 늘어날 뿐 아니라 알고리즘이 변하면 여러 군데를 손 봐야 한다. 소프트웨어의 많은 원칙과 기법이 중복을 없애거나 제어할 목적으로 나왔다. 관계형 데이터베이스의 정규형식, 객체지향 프로그래밍, 구조적 프로그래밍, AOP, COP 모두 중복 제거를 위해 나온 개념이다. 중복은 소프트웨어에서 모든 악의 근원이다. 



#### 결론

모든 시스템은 프로그래머가 설계한 '도메인 특화 언어'이다. 함수는 그 언어에서 동사고 클래스는 명사다. 프로그래밍 기술은 언어 설계의 기술이다. 시스템에서 발생하는 모든 동작을 설명하는 함수 계층이 그 언어이다. 이 장의 함수를 잘 만드는 규칙을 잘 따른다면 길이가 짧고, 이름이 좋고, 체계가 잡힌 함수를 만들 수 있다. 하지만 진짜 목표는 시스템이라는 이야기를 풀어가는데에 있다. 작성하는 함수가 분명하고 정확한 언어로 깔끔하게 맞아 떨어져야 이야기를 풀어가기가 쉬워진다. 



### 4. 주석

> 나쁜 코드에 주석을 달지 마라. 새로 짜라   - 브라이언 W.커니핸, P.J. 플라우거

잘 달린 주석은 그 어떤 정보보다 유용하다. 하지만 대부분의 주석은 필요하지 않다. 코드로 보통 의도를 표현하지 못해, 다른말로 실패를 만회하기 위해 주석이 사용되는 경우가 많다. 자신이 만든 난장판을 주석으로 설명하는게 아닌 난장판을 깨끗이 치우는게 낫다. 

주석이 필요한 상황이 되면 스스로 생각해야 한다. 코드로 의도를 표현할 방법이 없을까? 

주석에 이렇게 부정적인 이유는 주석은 오래될수록 코드에서 멀어지기 때문이다. 프로그래머들이 주석을 유지하고 보수하기는 현실적으로 어렵기 때문에 시간이 지날수록 주석은 거짓말을 하게 된다. 

코드는 일부가 여기 저기로 옮겨지기도 하면서 변화하고 진화한다. 하지만 주석이 언제나 코드를 따라가지는 않는다. 

프로그래머들이 주석을 엄격하게 관리해야 한다고 주장할 수도 있지만 그것보다 더 좋은 것은 코드를 깔끔하게 정리하고 표현력을 강화하는 방향으로, 그래서 애초에 주석이 필요 없는 방향으로 에너지를 쏟는게 더 낫다. 

부정확한 주석은 독자를 현혹하고 오도하기 때문에 주석이 아예 없는것보다 훨씬 나쁘다. 부정확한 주석은 더 이상 지킬 필요가 없는 규칙이나 지켜서는 안되는 규칙을 명시한다. 

진실은 코드 한곳에만 존재한다. 코드만이 정확한 정보를 제공하는 유일한 출처다. 아주 간혹 주석이 필요한 경우를 제외하고는 주석을 가능한 줄이도록 노력해야 한다. 

```java
// 직원에게 복지 혜택을 받을 자격이 있는지 검사한다
if((employee.flags & HOURLY_FLAG) && (employee.age > 65)) ... // 안좋은 코드 + 주석
    
if(employee.isEligibleForFullBenefits()) ... // 좋은 코드 (주석이 필요 없음) 
```



#### 좋은 주석

- 법적인 주석
  - 회사가 각 소스 파일의 첫 머리에 주석으로 저작권 정보와 소유권 정보를 넣어야 한다고 정하는 경우는 주석을 다는게 필요하고 타당하다.
- 의도를 설명하는 주석
  - 단순 구현을 이해하는 수준이 아닌 결정에 깔린 의도까지 설명하는 경우 유용한 주석이 될 수 있다. 
- 결과를 경고하는 주석
  - 프로그래머가 주석을 보고 실수를 면하게 할 수 있다.
- TODO 주석
  - 필요하지만 당장 구현하기 어려운 경우 앞으로 할 일을 남겨놓으면 편하다. 요즘 IDE는 TODO를 전부 찾아주는 기능을 제공하기 때문에 찾기도 쉽다. 하지만 TODO 주석 역시도 주기적으로 점검해서 없애도 괜찮으면 없애주는게 좋다. 
- 공개 API를 구현할때는 Javadocs를 열심히 작성해야 한다. 공개 API가 아닌 경우에는 Javadocs 주석이 요구하는 형식으로 인해 코드만 보기 싫고 산만해진다. 



#### 나쁜 주석

- 명확하지 않은 주석

- 같은 이야기를 반복하는 주석

- 의무적으로 다는 주석

- 있으나 마나 한 주석

  - 코드상으로도 이미 명확한데 주석을 다는 경우에 주석은 무의미하다.

- 이력을 기록하는 주석

  - 예전에는 소스코드 관리 시스템이 없어서 필요했을지 몰라도 지금은 아니다.

- 위치를 표시하는 주석

  - 소스파일에서 특정 위치를 표시하려고 주석을 사용할 때가 있다. 예를들어  `///// Actions/////////////////` 처럼 다는 경우이다. 유용할 때도 많지만 많이 사용하는 경우 가독성만 낮추게 된다. 

- 닫는 괄호 오른쪽에 다는 주석

  ```java
  try {
      ... 긴 코드 ...
      while {
          ... 긴 코드 ...
      } // while
      ... 긴 코드 ... 
  } // try
  ```

  - 중첩이 심하고 장황한 함수라면 의미가 있을 수 있지만 중첩이 심하고 장황한 함수가 아닌 작고 캡슐화된 함수를 만드는게 더 좋다. 

- 공로를 돌리거나 저자를 추가하는 주석

  - 소스코드 관리 시스템이 있는 현재 시점에서 이런 주석은 점차 부정확하고 쓸모없는 정보로 변하기 쉽다. 

- 주석으로 처리한 코드

  ```java
  InputStreamResponse response = new InputStreamResponse();
  response.setBody(formatter.getResultStream(), formatter.getByteCount());
  // InputStream resultsStream = formatter.getResultStream();
  // StreamReader reader = new StreamReader(resultStream);
  // response.setContent(reader.read(formatter.getByteCount()));
  ```

  주석으로 처리된 코드는 다른 사람이 봤을 때 이유가 있어서 남겨 놓았을 거라고 생각하기 때문에 지우기 어렵다. 1960년대에는 주석으로 처리한 코드가 유용했지만 요즘은 소스코드 관리 시스템이 있기 때문에 코드를 삭제하는게 낫다. 


- 너무 많은 정보
  - 주석에 역사적인 일이나 관련 없는 정보를 장황하게 늘어놓는건 안좋다. 
- 주석과 코드의 모호한 관계
  - 주석을 달아야 한다면 코드를 명확하게 설명하는 주석을 달아야 한다. 



### 5. 형식 맞추기

프로그램머라면 형식을 깔끔하게 맞춰 코드를 짜야 한다. 그러기 위해 간단한 규칙을 정하고 그 규칙을 착실히 따라야 한다. 코드를 읽는 독자들이 코드가 깔끔하고 일관적이며 꼼꼼하며 질서 정연하다고 감탄해야 한다. 



#### 형식을 맞추는 목적

어떤 개발자들은 '돌아가는 코드'가 개발자의 일차적인 의무라고 여길 수도 있다. 하지만 코드 특성상 오늘 구현한 기능이 다음 버전에서 바뀔 확률은 아주 높다. 그런데 오늘 구현한 코드의 가독성은 앞으로 바뀔 코드의 품질에 지대한 영향을 미친다. 맨 처음 잡아놓은 구현 스타일과 가독성 수준은 유지보수 용이성과 확장성에 계속 영향을 미친다. 



#### 세로 형식 맞추기

보통 한 소스코드 파일의 크기가 작을수록 이해하기가 쉽다. JUnit 같은 경우 500줄을 넘어가는 파일이 없고 대다수가 200줄 미만이다. JUnit같은 커다란 시스템도 이렇게 적은 줄의 소스코드 파일들로 구축이 가능하다면 다른 시스템도 충분히 가능하다. 

- 신문 기사처럼 작성하기
  - 신문기사는 위에서 아래로 기사를 읽는다. 최상단에 기사를 몇마디로 요약하는 표제가 나온다. 첫 문단은 전체 기사 내용을 요약한다. 쭉 읽으며 내려가면 세세한 사실이 조금씩 드러난다. 소스파일도 신문기사처럼 작성해야 한다. 이름은 간단하면서도 설명이 가능하도록, 소스 파일 첫 부분은 고차원 개념과 알고리즘을 설명하고 아래로 내려갈수록 의도를 세세하게 알 수 있도록 작성해야 한다. 
- 개념은 빈 행으로 분리하기
- 연관있는 코드는 가까이 배치하기 
  - 변수는 변수끼리 함수는 함수끼리 배치하는게 한눈에 읽기 쉽다
- 인스턴스 변수는 클래스 맨 처음에 선언하기
- 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치하기
- 개념적 유사성이 있는 코드를 가까이 배치하기



#### 가로 형식 맞추기

대형 프로젝트 7가지를 조사한 결과 대부분의 행이 20자~60자였다. 80자 이후의 행은 거의 존재하지 않았다. 결론적으로 짧은 행이 무조건 좋다. 



### 6. 객체와 자료구조

객체는 동작을 공개하고 자료를 숨긴다. 그래서 기존 동작을 변경하지 않으면서 새 객체 타입을 추가하기는 쉬운 반면 기존 객체에 새 동작을 추가하기는 어렵다. 

자료 구조는 별다른 동작 없이 자료를 노출한다(예 - DTO). 그래서 기존 자료 구조에 새 동작을 추가하기는 쉬우나 기존 기존 함수에 새 자료 구조를 추가하기는 어렵다.

어떤 시스템을 구현할 때 새로운 자료 타입을 추가하는 유연성이 필요하면 객체가 더 적합하다. 반면에 새로운 동작을 추가하는 유연성이 필요하면 자료구조와 절차적인 코드가 더 적합하다. 



 ### 7. 오류 처리

오류 처리는 깨끗하고 튼튼한 코드에 핵심적인 요소이다. 뭔가 잘못되면 바로 잡을 책임은 해당 코드를 작성한 프로그래머에게 있다. 그렇다고 오류 처리를 너무 많이 쓰면 실제 코드가 하는 일을 파악하기가 어려워 프로그램의 논리를 이해하기 어려워질 수 있다. 오류 처리를 통해 우아하고 고상하게 오류를 처리하면서 깨끗하고 튼튼한 코드를 작성하는 것은 기술이다. 



#### Try-Catch-Finally 문부터 작성하기

Try-catch 구조로 범위를 정의하면 TDD를 자연스럽게 사용하게 된다. 



#### 예외에 의미 제공하기

예외를 던질 때는 전후 상황을 충분히 덧붙이는게 좋다. 자바는 모든 예외에 호출 스택을 제공하지만 실패한 코드의 의도를 파악하려면 호출 스택만으로 부족할 때가 있다. 오류메세지에 정보(실패한 연산 이름과 실패 유형 등)를 담아 예외와 함께 던지거나 로깅 기능을 사용한다면 catch 블록에서 오류를 기록하는 방식으로 정보를 제공하는게 좋다. 





(To be continued ... )



